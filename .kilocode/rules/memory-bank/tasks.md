# lipunto - Задачи

## Добавление опциональных уведомлений

**Последнее выполнение:** [будет добавлено при реализации]
**Файлы для модификации:**

- [`switch_layout.py`](switch_layout.py) - Основной скрипт для добавления аргумента командной строки
- [`sw_last.sh`](sw_last.sh) - Обновление вызова с новым аргументом
- [`sw_selected.sh`](sw_selected.sh) - Обновление вызова с новым аргументом
- [`lipunto.kksrc`](lipunto.kksrc) - Обновление конфигурации KDE

**Шаги реализации:**

1. Добавить аргумент командной строки `--no-popup` в `switch_layout.py`
2. Модифицировать функцию `main()` для обработки нового аргумента
3. Обновить вызов `popup_message()` с учетом нового параметра
4. Обновить shell скрипты для передачи аргумента
5. Обновить конфигурацию KDE для поддержки новой опции

**Важные замечания:**

- Сохранить обратную совместимость (по умолчанию уведомления включены)
- Добавить проверку наличия аргумента перед вызовом `popup_message()`
- Обеспечить корректную обработку ошибок при парсинге аргументов

**Пример реализации:**

```python
# В функции main()
parser.add_argument("--no-popup", action="store_true", help="Disable popup notifications")

# При вызове popup_message
if not args.no_popup:
    popup_message(f"{selection_text}\n{converted_text}")
```

## Архитектурные изменения

- Добавление нового параметра в аргументы командной строки
- Условный вызов функции отображения уведомлений
- Обновление всех точек входа (shell скрипты)

## Тестирование

- Проверка работы с включенными уведомлениями (по умолчанию)
- Проверка работы с отключенными уведомлениями (`--no-popup`)
- Проверка обратной совместимости
- Тестирование обоих режимов (last и selected)

## Отключение логирования по умолчанию

**Последнее выполнение:** 2025-08-10
**Файлы для модификации:**

- [`config_manager.py`](config_manager.py) - Модификация класса LoggingConfig
- [`switch_layout.py`](switch_layout.py) - Обновление функции main()
- [`logger.py`](logger.py) - Модификация класса LipuntoLogger

**Шаги реализации:**

1. Добавить поле `enabled: bool = False` в класс `LoggingConfig`
2. Изменить настройки по умолчанию: `level = "WARNING"`, `console = False`
3. Добавить аргумент командной строки `--enable-logging`
4. Модифицировать функцию `main()` для обработки нового аргумента
5. Обновить класс `LipuntoLogger` для корректной обработки отключенного логирования
6. Добавить проверку в `_get_log_level()` для отключенного логирования

**Важные замечания:**

- Сохранить обратную совместимость (все существующие аргументы продолжают работать)
- При отключенном логировании не создавать обработчики и не записывать в файлы
- При включении логирования доступны все опции
- Минимизировать накладные расходы при отключенном логировании

**Пример реализации:**

```python
# В LoggingConfig
enabled: bool = Field(False, description="Включить логирование")
level: str = Field("WARNING", description="Уровень логирования")
console: bool = Field(False, description="Выводить в консоль")

# В main()
logging_enabled = args.enable_logging
logging_config = LoggingConfig(
    enabled=logging_enabled,
    level=args.log_level if logging_enabled else "WARNING",
    console=not args.no_console_log if logging_enabled and args.no_console_log is not None else False,
)

# В LipuntoLogger
def __init__(self, config):
    enabled = self.config.get("enabled", False)
    if not enabled:
        self.logger.setLevel(logging.CRITICAL + 1)
        return
    # ... остальная инициализация
```

## Тестирование отключения логирования

- Проверка отключенного логирования по умолчанию (нет вывода в консоль, нет файлов)
- Проверка включенного логирования с разными уровнями
- Проверка записи логов в файл при включении
- Проверка обратной совместимости
- Тестирование обоих режимов (last и selected)
